<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Correlated equilibrium</title>
<!-- 2015-09-22 Tue 11:41 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Christoph Schottmueller" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Correlated equilibrium</h1>
<p>
A correlated equilibrium is eventually nothing but a probability distribution \(f\) over action profiles. Which conditions does \(f\) has to satisfy to be a correlated equilibrium? If an action profile in which player \(i\) plays \(a_i\) is in the support of \(f\), then \(i\) must find it optimal to play \(a_i\) whenever it is "recommended" to him, i.e. 
</p>

<p>
$$\sum_{a_{-i}\in A_{-i}} u_i(a_i,a_{-i}) \frac{f(a_i,a_{-i})}{\sum_{a_{-i}\in A_{-i}}f(a_i,a_{-i})}\geq \sum_{a_{-i}\in A_{-i}} u_i(a_i',a_{-i}) \frac{f(a_i,a_{-i})}{\sum_{a_{-i}\in A_{-i}}f(a_i,a_{-i})}\qquad\text{for all } a_i'\in A_i$$
</p>

<p>
where \(\frac{f(a_i,a_{-i})}{\sum_{a_{-i}\in A_{-i}}f(a_i,a_{-i})}\) is the conditional  probability of \((a_i,a_{-i})\) given that \(a_i\) was "recommended". Multiplying the expression above through by \(\sum_{a_{-i}\in A_{-i}}f(a_i,a_{-i})\) yields
</p>

<p>
$$\sum_{a_{-i}\in A_{-i}} u_i(a_i,a_{-i}) f(a_i,a_{-i}) \geq \sum_{a_{-i}\in A_{-i}} u_i(a_i',a_{-i}) f(a_i,a_{-i})\qquad\text{for all } a_i'\in A_i$$
</p>

<p>
for any \(a_i\) in the support of \(f\). This inequality can also be written as 
</p>

<p>
$$\sum_{a_{-i}\in A_{-i}} (u_i(a_i,a_{-i})-u_i(a_i',a_{-i})) f(a_i,a_{-i}) \geq 0\qquad\text{for all } a_i'\in A_i.$$
</p>

<p>
This inequality is linear in \(f\). Note that this inequality also holds for \(a_i\) that are not in the support of \(f\) (as \(f(a_i,a_{-i})\) will then be zero). We can therefore conclude that a correlated equilibrium is characterized by a system of linear inequalities: one set of inequalities as above for each action of each player. Any solution \(f\) of this system of inequalities that also satisfies the regularity conditions (recall that \(f\) is a probability distribution!)
$$f(a)\geq 0\quad\text{for all }a\in A\qquad\text{and}\qquad \sum_{a\in A}f(a)=1$$
is a correlated equilibrium. Note that there is usually a whole range of correlated equilibria: The set of solutions to a number of linear inequality constraints is convex. This means that we have a continuum of solutions whenever there are two distinct solutions. Also note that as the number of players and/or actions increases, the number of inequalities increases relatively quickly.
</p>

<p>
However, systems of linear inequalities can be  solved relatively easily numerically and this is what we do below. We will use the simple example game:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border" align="center">
<caption class="t-above"><span class="table-number">Table 1:</span> Chicken</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">L</th>
<th scope="col" class="left">R</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">U</td>
<td class="left">0,0</td>
<td class="left">5,1</td>
</tr>

<tr>
<td class="left">D</td>
<td class="left">1,5</td>
<td class="left">4,4</td>
</tr>
</tbody>
</table>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #859900;">from</span> numpy <span style="color: #859900;">import</span> *
<span style="color: #859900;">from</span> openopt <span style="color: #859900;">import</span> LP
<span style="color: #859900;">from</span> operator <span style="color: #859900;">import</span> add

<span style="color: #586e75; font-style: italic;">##</span><span style="color: #586e75; font-style: italic;">TO DO: funnily, the solver cannot solve games in which each player has a unique rationalizable action</span>
<span style="color: #586e75; font-style: italic;">## </span><span style="color: #586e75; font-style: italic;">and returns an error there.</span>
<span style="color: #586e75; font-style: italic;">##</span><span style="color: #586e75; font-style: italic;">This could be easily fixed by handing the game to the rationalizability solver in the "except" statement below.</span>

<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">the game is read in</span>
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">format: first we keep the action of P2 fixed and vary P1's action</span>
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">hence, we write the columns of the game table as lists</span>
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">for 3 players: holding P3's action fixed we have a two player game as below;</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">simply enter a list of these two player games (one for each action of P3);</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">for more players: proceed as going from 2 to 3</span>
<span style="color: #268bd2;">game</span> = [[(0,0),(1,5)],[(5,1),(4,4)]]
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">example game with three actions per player</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">game = [[(0,0),(1,1),(1,1)],[(1,1),(0,0),(1,1)],[(1,1),(1,1),(0,0)]] </span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">example game with three players (see MSZ example 8.2)</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">game = [[[(0,1,3),(1,1,1)],[(0,0,0),(1,0,0)]],[[(2,2,2),(2,2,0)],[(0,0,0),(2,2,2)]],[[(0,1,0),(1,1,1)],[(0,0,0),(1,0,3)]]]</span>
<span style="color: #586e75; font-style: italic;">##</span><span style="color: #586e75; font-style: italic;">example game with only one rationalizable action per player (currently cannot be solved)</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">game = [[(3,2),(1,1)],[(2,1),(1,3)]]</span>
<span style="color: #586e75; font-style: italic;">##</span><span style="color: #586e75; font-style: italic;">matching pennies example: there is a unique correlated equilibrium</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">game = [[(1,-1),(-1,1)],[(-1,1),(1,-1)]]</span>

<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">determine the set of all payoff profiles and write them in one long list</span>
<span style="color: #268bd2;">Ulist</span> = game <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">will become a list of all payoff profiles which is similar to as set of all action profiles</span>
<span style="color: #268bd2;">no_action</span> = [] <span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">a vector which contains the number of actions of each player</span>

<span style="color: #268bd2;">temp</span> = 1
<span style="color: #859900;">while</span> <span style="color: #859900;">type</span>(Ulist[0])!=<span style="color: #859900;">tuple</span>:
    no_action.insert(0,<span style="color: #859900;">len</span>(Ulist)/temp)
    <span style="color: #268bd2;">temp</span> = temp*no_action[0]
    <span style="color: #268bd2;">Ulist</span> = [item <span style="color: #859900;">for</span> sublist <span style="color: #859900;">in</span> Ulist <span style="color: #859900;">for</span> item <span style="color: #859900;">in</span> sublist]
no_action.insert(0,<span style="color: #859900;">len</span>(Ulist)/temp)
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">resulting format of Ulist:</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">Ulist is list of payoff tuples (for 2 player games, we move column by column):</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">-first tuple is when every player uses his first action</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">-second tuple: P1 uses his second action, everyone else his first</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">-third tuple: P1 uses his third action, everyone else his first etc.</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">-...</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">-..:P2 uses second action, everyone else uses first</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">-...: P1 and P2 use second action; everyone else first action</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">...</span>

<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">construct a payoff list by player,</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">Ulist_by_player contains one tuple for each player,</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">the i-th tuple contains Pi's payoffs for each action profile (ordered as in Ulist)</span>
<span style="color: #268bd2;">Ulist_by_player</span> = <span style="color: #859900;">zip</span>(*Ulist)


<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">creates a vector with one entry for every action profile (ordered as in Ulist)</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">entry of the vector is "1." if player i uses action k in this action profile</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">entry is "0." otherwise</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">note: k=0 is the first action of a player, i=0 is first player</span>
<span style="color: #859900;">def</span> <span style="color: #268bd2;">aik_indicator</span>(i,k):
    <span style="color: #268bd2;">temp</span> = 1
    <span style="color: #268bd2;">j</span> = 0
    <span style="color: #859900;">while</span> j &lt; <span style="color: #859900;">len</span>(no_action):<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">j cycles through all players</span>
        <span style="color: #859900;">if</span> j&lt;i:
            <span style="color: #268bd2;">temp</span> = temp*no_action[j]
        <span style="color: #859900;">elif</span> j==i:
            <span style="color: #268bd2;">x</span> = [0.]*temp*k + [1.]*temp + [0.]*temp*(no_action[i]-k-1)
            <span style="color: #268bd2;">temp</span> = 1
        <span style="color: #859900;">else</span>:
            <span style="color: #268bd2;">temp</span> = temp*no_action[j]
        <span style="color: #268bd2;">j</span>+=1
    <span style="color: #268bd2;">x</span> = x*temp
    <span style="color: #859900;">return</span> x


<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">for i&gt;0: in Ulist, several consecutive payoff profiles have the same action for player i</span>
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">this function calculates how many profiles where i plays ai are next to each other</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">before a profile comes in which i plays another action ai'</span>
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">note i=0 is the first player</span>
<span style="color: #859900;">def</span> <span style="color: #268bd2;">blockwidth</span>(i):
    <span style="color: #859900;">if</span> i == 0:
        <span style="color: #859900;">return</span> 1
    <span style="color: #859900;">else</span>:
        <span style="color: #859900;">return</span> prod(no_action[:i])

<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">construct ui(ap,a-i)-ui(ak,a-i)</span>
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">take i's payoff vector, generate a shifted payoff vector z</span>
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">such that the entry ui(ap,a-i) is at the same position in z as ui(ak,a-i) is in the original payoff vector</span>
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">note 1: i=0 is first player</span>
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">note 2: construction only makes sense at entries where a-i is held constant, i.e. there are some non-sense entries generated which will be irrelevant</span>
<span style="color: #859900;">def</span> <span style="color: #268bd2;">udiff</span>(i,k,p):
    <span style="color: #268bd2;">width</span> = blockwidth(i)
    <span style="color: #268bd2;">y</span> = <span style="color: #859900;">list</span>(Ulist_by_player[i])
    <span style="color: #859900;">if</span> p&lt;k:
        <span style="color: #268bd2;">z</span> = [0.]*width*(k-p) + y
        <span style="color: #268bd2;">z</span> = z[:<span style="color: #859900;">len</span>(Ulist)]
    <span style="color: #859900;">if</span> p&gt;k:
        <span style="color: #268bd2;">z</span> = y[width*(p-k):]
        <span style="color: #268bd2;">z</span> = z + [0.]*width*(p-k)
    <span style="color: #859900;">if</span> p==k:
        <span style="color: #268bd2;">z</span> = y
    <span style="color: #859900;">return</span> subtract(z,<span style="color: #859900;">list</span>(Ulist_by_player[i]))


<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">to find the Pareto optimal equilibrium, we create a vector that sums for each action profile the payoffs of all players</span>
<span style="color: #268bd2;">welfare</span> = [0.]*<span style="color: #859900;">len</span>(Ulist)
<span style="color: #859900;">for</span> payoff <span style="color: #859900;">in</span> Ulist_by_player:
    <span style="color: #268bd2;">welfare</span> = <span style="color: #859900;">map</span>(add,welfare ,<span style="color: #859900;">list</span>(payoff))


<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">construct inequality constraints and solve</span>
<span style="color: #268bd2;">neg_welfare</span> = multiply(-1.,welfare)<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">objective as we will run a minimization problem</span>
<span style="color: #268bd2;">lb</span> = [0.]*<span style="color: #859900;">len</span>(Ulist)
<span style="color: #268bd2;">ub</span> = [1.]*<span style="color: #859900;">len</span>(Ulist)
<span style="color: #268bd2;">Aeq</span> = [[1.]*<span style="color: #859900;">len</span>(Ulist)]
<span style="color: #268bd2;">beq</span> = (1.,)
<span style="color: #268bd2;">A</span>  = []
<span style="color: #268bd2;">b</span> = []
<span style="color: #268bd2;">player</span> = 0
<span style="color: #859900;">while</span> player&lt;<span style="color: #859900;">len</span>(no_action):
    <span style="color: #268bd2;">action</span> = 0
    <span style="color: #859900;">while</span> action &lt; no_action[player]:
        <span style="color: #859900;">for</span> k <span style="color: #859900;">in</span> <span style="color: #859900;">range</span>(0,no_action[player]):
            A.append(multiply(udiff(player,action,k),aik_indicator(player,action)))
            b.append(0.)
        <span style="color: #268bd2;">action</span> = action + 1
    <span style="color: #268bd2;">player</span> = player +1
<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">print A,b</span>
<span style="color: #268bd2;">p</span> = LP(neg_welfare, A=A,b=b,lb=lb,ub=ub,Aeq=Aeq,beq=beq)<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">we use the artificial minimization problem under the constraint that action gives a weakly higher payoff than any other action; if no feasible solution is obtained than action is dominated</span>
<span style="color: #268bd2;">p.iprint</span> = -1
<span style="color: #859900;">try</span>:
    <span style="color: #268bd2;">r</span> = p.minimize(<span style="color: #2aa198;">'pclp'</span>)
    <span style="color: #268bd2;">pminw</span> = LP(welfare, A=A,b=b,lb=lb,ub=ub,Aeq=Aeq,beq=beq)
    <span style="color: #268bd2;">pminw.iprint</span> = -1
    <span style="color: #268bd2;">rminw</span> = pminw.minimize(<span style="color: #2aa198;">'pclp'</span>)

<span style="color: #859900;">except</span>:
    <span style="color: #859900;">print</span> <span style="color: #2aa198;">"Solver returns error. Probably, each player has a unique rationalizable action (check with rationalizability solver)."</span>
    <span style="color: #2aa198;">quit</span>()

<span style="color: #586e75; font-style: italic;">###</span><span style="color: #586e75; font-style: italic;">formatting the result back into the same format as the game input</span>
<span style="color: #586e75; font-style: italic;"># </span><span style="color: #586e75; font-style: italic;">first: rounding</span>
<span style="color: #268bd2;">outr</span> = []
<span style="color: #859900;">for</span> item <span style="color: #859900;">in</span> r.xf:
    outr.append(<span style="color: #859900;">round</span>(item,3))

<span style="color: #268bd2;">outrminw</span> = []
<span style="color: #859900;">for</span> item <span style="color: #859900;">in</span> rminw.xf:
    outrminw.append(<span style="color: #859900;">round</span>(item,3))

<span style="color: #859900;">def</span> <span style="color: #268bd2;">backtolist</span>(i,inlist):
    <span style="color: #268bd2;">width</span> = blockwidth(i)
    <span style="color: #268bd2;">out</span> = []
    <span style="color: #859900;">for</span> k <span style="color: #859900;">in</span> <span style="color: #859900;">range</span>(0,<span style="color: #859900;">len</span>(inlist),width):
        <span style="color: #268bd2;">temp</span> = inlist[k:k+width]
        <span style="color: #859900;">if</span> i&gt;1:
            <span style="color: #268bd2;">temp</span> = backtolist(i-1,temp)
        out.append(temp)
    <span style="color: #859900;">return</span> out

<span style="color: #268bd2;">outmax</span> = backtolist(<span style="color: #859900;">len</span>(no_action)-1,outr)
<span style="color: #268bd2;">outmin</span> = backtolist(<span style="color: #859900;">len</span>(no_action)-1,outrminw)

<span style="color: #586e75; font-style: italic;">#</span><span style="color: #586e75; font-style: italic;">format of output is now as in game input</span>
<span style="color: #859900;">print</span> <span style="color: #2aa198;">'a correlated equilibrium maximizing the sum of payoffs is'</span>, outmax
<span style="color: #859900;">print</span> <span style="color: #2aa198;">'a correlated equilibrium minimizing the sum of payoffs is'</span>, outmin
</pre>
</div>

<pre class="example">
a correlated equilibrium maximizing the sum of payoffs is [[0.0, 0.333], [0.333, 0.333]]
a correlated equilibrium minimizing the sum of payoffs is [[0.333, 0.333], [0.333, 0.0]]
</pre>
</div>
<div id="postamble" class="status">
 <p>author: Christoph Schottmueller <br> license: Creative Commons Attribution ShareAlike 4.0</p>
</div>
</body>
</html>
